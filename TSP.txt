from collections import defaultdict

def bottom_up(n, _edges):
    edges = defaultdict(list)
    for (u, v, cost) in _edges: # undirected
        edges[u].append((v, cost))
        edges[v].append((u, cost))

    best = defaultdict(lambda : defaultdict(lambda: float("inf")))
    # best[size][S, i]  --- organize best by size (|S|)
    best[1][frozenset([0]), 0] = 0 # set is unhashable
    
    back = {} # back[S, i], no need to organize by size

    for size in xrange(2, n+1): # 2 to n
        for S, j in best[size-1]: # all reachable (S, j) with |S|=size-1
            for i, cost in edges[j]:
                if i not in S:
                    newS = S | frozenset([i])  # expand visited set
                    newcost = best[size-1][S, j] + cost
                    if newcost < best[size][newS, i]: # forward update
                        best[size][newS, i] = newcost
                        back[newS, i] = j

    full = frozenset(range(n))
    # only works for undirected graph
    goal, goalj = min((best[n][full, j] + cost, j) for j, cost in edges[0])
    
    if goal < float("inf"):
        return goal, solution(back, full, goalj) + [0]
    return None

def solution(back, S, v):
    if v == 0:
        return [0]
    return solution(back, S - frozenset([v]), back[S, v]) + [v]

print bottom_up(3, [(0,1,1), (1,2,2), (2,0,3)])
print bottom_up(3, [(0,1,1), (1,2,2)]) # impossible
print bottom_up(4, [(0,1,1), (0,2,5), (1,2,1), (2,3,1), (1,3,6)])
print bottom_up(4, [(0,1,1), (0,2,5), (1,2,1), (2,3,1), (1,3,6), (3,0,1)])
