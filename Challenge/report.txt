for question one, we have an array that length is n. And we have a rule for what kind of style can be a pair, such as AU, GU, GC. As the rule we have, we just can get the pair which one of the pair in the front part and another is in the back part or two element are close to each other, such as just next to each other, no cross to other pair. To find the pair in list, I will use two pivot that one i is ar the beginning of the list and other one j is at the end of the list. And I also need a pivot k to cut the list in two pieces because the best one may not as the full list. So we should consider all possible result. I also need to crate a space to stove the best solution after each step, but I just need to find the best one, so after each step I will compare the new result with the best one I saved before. If the new result is better it will replace the best we saved before, otherwise keep the best and do other step. After finishing all step and return the best. To find the best, in first time, k equal to i, so it means that we will calculate the whole list and return the best result. If k is bigger than i and small than j, we will calculate each part and sum each part and return. When we calculate, we put i at the beginning and j at the end for case I, and there are no k. Fot this part, we have two options that is choose or not choose. At first, we should start at a[i] and find a[j] is the another part for a[i] to become a pair or not. If not we will find if a[i+1] is the other parts of a[i] to become a pair. In case II, we will do the same job in case I then will combine two parts' result and compare with the best result we got before.


for question two, we will do the same jon in question one. The biggest different is that we will not find the best solution. I just want to know have many solution we will get. So, the calculation part is similar we just add a function to calculate the number. But when we do that, we will found that we will find some solution that we are already get. So the result will more than the real number. So we can just insert the solution in a list and calculate the len of the list that we can get the number we want and avoid the same one.I will use two pivot that one i is ar the beginning of the list and other one j is at the end of the list. And I also need a pivot k to cut the list in two pieces because the best one may not as the full list. So we should consider all possible result. After we found the possible result, we will storage the result. But before we store it, we will check the result we just get is or is not we get before, if not we store it or pass it. After finish all process, we just get the length of the list we can know how many we have and get the number of all possible results.

for question three, we can use some idea when we solve the nbest problem and the question two. In question two, we find all possible solution and we  can find  the k best solution for this problem. For the required for this problem, we will create a space for save the k best, so the space should be k. When we find one solution, we will compare it with what we already have and if this is better it will replace the worst one in the list. The calculate part is also similar with question one and two. But the storage part is a little different. Because of we just need k solutions, so we just need k space as what I said  before.